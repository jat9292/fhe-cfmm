import { expect } from "chai";
import { Signer } from "ethers";
import { ethers } from "hardhat";

import { EncryptedERC20 } from "../../types/contracts/EncryptedERC20";
import { createInstances } from "../instance";
import { Signers, getSigners } from "../signers";
import { FhevmInstances } from "../types";
import { createTransaction, waitForBlock } from "../utils";

describe("EncryptedERC20", async () => {
  let signers: Signers;
  let tokenA: EncryptedERC20;
  let tokenB: EncryptedERC20;
  let instancesTokenA: FhevmInstances;
  let instancesTokenB: FhevmInstances;
  let tokenAAddress: string;
  let tokenBAddress: string;

  before(async () => {
    signers = await getSigners(ethers);
    const EncryptedERC20Factory = await ethers.getContractFactory("EncryptedERC20");
    tokenA = await EncryptedERC20Factory.connect(signers.alice).deploy("EncTokenA", "ETA");
    await tokenA.waitForDeployment();
    tokenB = await EncryptedERC20Factory.connect(signers.alice).deploy("EncTokenB", "ETB");
    await tokenB.waitForDeployment();
    tokenAAddress = await tokenA.getAddress();
    tokenBAddress = await tokenB.getAddress();

    instancesTokenA = await createInstances(tokenAAddress, ethers, signers);
    instancesTokenB = await createInstances(tokenBAddress, ethers, signers);
  });

  it("should transfer tokens between two users", async () => {
    //let currentBlockNumber = await ethers.provider.getBlockNumber();
    //await waitForBlock(BigInt(currentBlockNumber + 2), ethers); // to make sure to send next the following swap transactions in a single same block

    let encryptedAmount = instancesTokenA.alice.encrypt32(4_294_967_295); // supply is type(uint32).max
    const tx1 = await createTransaction(tokenA.mint, encryptedAmount);
    await tx1.wait();

    encryptedAmount = instancesTokenB.alice.encrypt32(4_294_967_295); // supply is type(uint32).max
    const tx2 = await createTransaction(tokenB.mint, encryptedAmount);
    await tx2.wait();

    let encryptedTransferAmount = instancesTokenA.alice.encrypt32(100_000_000);
    await createTransaction(tokenA["transfer(address,bytes)"], signers.bob.address, encryptedTransferAmount);
    encryptedTransferAmount = instancesTokenB.alice.encrypt32(100_000_000);
    await createTransaction(tokenB["transfer(address,bytes)"], signers.bob.address, encryptedTransferAmount);

    encryptedTransferAmount = instancesTokenA.alice.encrypt32(100_000_000);
    await createTransaction(tokenA["transfer(address,bytes)"], signers.carol.address, encryptedTransferAmount);
    encryptedTransferAmount = instancesTokenB.alice.encrypt32(100_000_000);
    const tx3 = await createTransaction(
      tokenB["transfer(address,bytes)"],
      signers.carol.address,
      encryptedTransferAmount,
    );
    await tx3.wait();

    const carolTokenB = tokenB.connect(signers.carol);
    const tokenCarol = instancesTokenB.carol.getTokenSignature(tokenBAddress)!;
    const encryptedBalBCarol = await carolTokenB.balanceOf(tokenCarol.publicKey, tokenCarol.signature);
    // Decrypt the balance
    const balanceCarol = instancesTokenB.carol.decrypt(tokenBAddress, encryptedBalBCarol);
    expect(balanceCarol).to.equal(100_000_000);
  });
});
/*
    const tokenAlice = this.instances.alice.getTokenSignature(this.contractAddress)!;

    const encryptedBalanceAlice = await this.erc20.balanceOf(tokenAlice.publicKey, tokenAlice.signature);

    // Decrypt the balance
    const balanceAlice = this.instances.alice.decrypt(this.contractAddress, encryptedBalanceAlice);

    expect(balanceAlice).to.equal(10000 - 1337);

    const bobErc20 = this.erc20.connect(this.signers.bob);

    const tokenBob = this.instances.bob.getTokenSignature(this.contractAddress)!;

    const encryptedBalanceBob = await bobErc20.balanceOf(tokenBob.publicKey, tokenBob.signature);

    // Decrypt the balance
    const balanceBob = this.instances.bob.decrypt(this.contractAddress, encryptedBalanceBob);

    expect(balanceBob).to.equal(1337);/*
  });
});


/*
  it("should mint the contract", async function () {
    const encryptedAmount = this.instances.alice.encrypt32(1000);
    const transaction = await createTransaction(this.erc20.mint, encryptedAmount);
    await transaction.wait();
    // Call the method
    const token = this.instances.alice.getTokenSignature(this.contractAddress) || {
      signature: "",
      publicKey: "",
    };
    const encryptedBalance = await this.erc20.balanceOf(token.publicKey, token.signature);
    // Decrypt the balance
    const balance = this.instances.alice.decrypt(this.contractAddress, encryptedBalance);
    expect(balance).to.equal(1000);

    const encryptedTotalSupply = await this.erc20.getTotalSupply(token.publicKey, token.signature);
    // Decrypt the total supply
    const totalSupply = this.instances.alice.decrypt(this.contractAddress, encryptedTotalSupply);
    expect(totalSupply).to.equal(1000);
  });

  it("should transfer tokens between two users", async function () {
    const encryptedAmount = this.instances.alice.encrypt32(10000);
    const transaction = await createTransaction(this.erc20.mint, encryptedAmount);
    await transaction.wait();

    const encryptedTransferAmount = this.instances.alice.encrypt32(1337);
    const tx = await createTransaction(
      this.erc20["transfer(address,bytes)"],
      this.signers.bob.address,
      encryptedTransferAmount,
    );
    await tx.wait();

    const tokenAlice = this.instances.alice.getTokenSignature(this.contractAddress)!;

    const encryptedBalanceAlice = await this.erc20.balanceOf(tokenAlice.publicKey, tokenAlice.signature);

    // Decrypt the balance
    const balanceAlice = this.instances.alice.decrypt(this.contractAddress, encryptedBalanceAlice);

    expect(balanceAlice).to.equal(10000 - 1337);

    const bobErc20 = this.erc20.connect(this.signers.bob);

    const tokenBob = this.instances.bob.getTokenSignature(this.contractAddress)!;

    const encryptedBalanceBob = await bobErc20.balanceOf(tokenBob.publicKey, tokenBob.signature);

    // Decrypt the balance
    const balanceBob = this.instances.bob.decrypt(this.contractAddress, encryptedBalanceBob);

    expect(balanceBob).to.equal(1337);
  });
});

*/
